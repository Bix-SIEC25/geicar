/**
 * @file    can_communication.c
 * @author  Sebastien DI MERCURIO
 * @version V1.0
 * @date    20 Aout 2023
 * @brief   Functions for CAN communication.
 * This file contains the implementation of functions to initialize and manage CAN communication,
 */

#include "can_communication.h"
#include "configuration.h"

#include "FreeRTOS.h"
#include "queue.h"
#include "semphr.h"
#include "task.h"

#include "tasks.h"

//extern int mode;
//extern int cmdLRM, cmdRRM, cmdSFM, cmdPOS;
//extern GPIO_PinState en_MARG, en_MARD, en_MAV, en_POS;
//
//extern int leftRearSpeed;
//extern int rightRearSpeed;
//extern int steeringAngle;
//extern int UPDATE_CMD_FLAG;
//extern int commCheckingRequest;

extern CAN_HandleTypeDef hcan;

CAN_TxHeaderTypeDef   TxHeader;
CAN_RxHeaderTypeDef   RxHeader;
uint8_t               TxData[8];
uint8_t               RxData[8];
uint32_t              TxMailbox;

/* -------------------------------------------------------------------------
 * Déclaration du sémaphore de reception (statique)
 * ------------------------------------------------------------------------- */
static StaticSemaphore_t xCanReceptionSemaphoreBuffer;
SemaphoreHandle_t xCanReceptionSemaphore = NULL;

void CAN_COM_FilterConfig(void);

void CAN_COM_Init(void) {
	// HW init is done in mx_can_init() generated by CubeMX

	// Filters init
	CAN_COM_FilterConfig();

	/* Start the CAN peripheral */
	if (HAL_CAN_Start(&hcan) != HAL_OK)
	{
		/* Start Error */
		assert_param(0);
		Error_Handler();
	}

	/* Activate CAN RX notification */
	if (HAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO0_MSG_PENDING) != HAL_OK)
	{
		/* Notification Error */
		assert_param(0);
		Error_Handler();
	}

	/* Création du sémaphore de calibration (statiquement) */
	xCanReceptionSemaphore = xSemaphoreCreateBinaryStatic(&xCanReceptionSemaphoreBuffer);
	if (xCanReceptionSemaphore == NULL) {
		// Erreur : pas de mémoire statique ?
		Error_Handler();
	}

	/* Au démarrage, le sémaphore est "pris" */
	xSemaphoreTake(xCanReceptionSemaphore, 0);
}

//void CAN_COM_FilterConfig(void)
//{
//	CAN_FilterTypeDef canFilterConfig;
//
//	canFilterConfig.FilterBank = 0;
//	canFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
//	canFilterConfig.FilterScale = CAN_FILTERSCALE_16BIT;
//	canFilterConfig.FilterIdHigh = CAN_ID_MOTORS_CMD << 5;
//	canFilterConfig.FilterIdLow = CAN_ID_CALIBRATION_MODE << 5;
//	canFilterConfig.FilterMaskIdHigh = CAN_ID_COMM_CHECKING << 5;
//	canFilterConfig.FilterMaskIdLow = 0x0000; // Don't care about the lower bits;
//	canFilterConfig.FilterFIFOAssignment = CAN_FILTER_FIFO0;
//	canFilterConfig.FilterActivation = ENABLE;
//	canFilterConfig.SlaveStartFilterBank = 14; // Not relevant for single CAN instance
//
//	if( HAL_CAN_ConfigFilter(&hcan, &canFilterConfig) != HAL_OK )
//	{
//		assert_param(0);
//		Error_Handler();
//	}
//}

void CAN_COM_FilterConfig(void)
{
	 CAN_FilterTypeDef sFilterConfig;

	    // --- Configuration du filtre 0 pour IDs 0x400 (CAN_ID_CALIBRATION_MODE) et 0x410 (CAN_ID_COMM_CHECKING) ---
	    sFilterConfig.FilterBank = 0;
	    sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
	    sFilterConfig.FilterScale = CAN_FILTERSCALE_16BIT;

	    // ID de base (CAN_ID_CALIBRATION_MODE , 0x400) et le masque pour les IDs 0x400 et 0x410
	    // L'ID 0x400 et le masque 0x7EF (en 11 bits) permettent de capturer
	    // les deux IDs qui ne diffèrent que par un bit.
	    sFilterConfig.FilterIdHigh = (CAN_ID_CALIBRATION_MODE << 5); // Décalage de 5 bits pour l'ID
	    //sFilterConfig.FilterMaskIdHigh = (0x7EF << 5); // Décalage de 5 bits pour le masque
	    sFilterConfig.FilterMaskIdHigh = (~((CAN_ID_CALIBRATION_MODE ^ CAN_ID_COMM_CHECKING)) << 5); // Décalage de 5 bits pour le masque
	    sFilterConfig.FilterIdLow = 0x0000;
	    sFilterConfig.FilterMaskIdLow = 0x0000;

	    sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0;
	    sFilterConfig.FilterActivation = ENABLE;

	    if (HAL_CAN_ConfigFilter(&hcan, &sFilterConfig) != HAL_OK)
	    {
	        Error_Handler();
	    }

	    // --- Configuration du filtre 1 pour l'ID 0x100 (CAN_ID_MOTORS_CMD) ---
	    sFilterConfig.FilterBank = 1;
	    sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
	    sFilterConfig.FilterScale = CAN_FILTERSCALE_16BIT;

	    // ID 0x100 et un masque complet (0x7FF) pour n'accepter que cet ID exact.
	    sFilterConfig.FilterIdHigh = (CAN_ID_MOTORS_CMD << 5);
	    sFilterConfig.FilterMaskIdHigh = (0x7FF << 5);
	    sFilterConfig.FilterIdLow = 0x0000;
	    sFilterConfig.FilterMaskIdLow = 0x0000;

	    sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0;
	    sFilterConfig.FilterActivation = ENABLE;

	    if (HAL_CAN_ConfigFilter(&hcan, &sFilterConfig) != HAL_OK)
	    {
	        Error_Handler();
	    }

//	CAN_FilterTypeDef canFilter;
//
//	/* --- Banque 0 : ID 0x100 et 0x400 --- */
//	canFilter.FilterBank = 0;
//	canFilter.FilterMode = CAN_FILTERMODE_IDMASK;
//	canFilter.FilterScale = CAN_FILTERSCALE_32BIT;
//	canFilter.FilterFIFOAssignment = CAN_FILTER_FIFO0;
//	canFilter.FilterActivation = ENABLE;
//	//canFilter.SlaveStartFilterBank = 14;
//
//	// ID standard : doit être aligné sur bits 31:21
//	canFilter.FilterIdHigh     = (CAN_ID_MOTORS_CMD << 5);  // 11 bits << 5
//	canFilter.FilterIdLow      = 0x0000;
//	canFilter.FilterMaskIdHigh = 0x07FF; // Select this ID only;
//	canFilter.FilterMaskIdLow  = 0xFFFF;
//
//	if (HAL_CAN_ConfigFilter(&hcan, &canFilter) != HAL_OK)
//	{
//		Error_Handler();
//	}
//
//	// ID standard : doit être aligné sur bits 31:21
//	canFilter.FilterIdHigh     = (CAN_ID_COMM_CHECKING << 5);  // 11 bits << 5
//	canFilter.FilterIdLow      = 0x0000;
//	canFilter.FilterMaskIdHigh = 0x07FF; // Select this ID only;
//	canFilter.FilterMaskIdLow  = 0xFFFF;
//
//	if (HAL_CAN_ConfigFilter(&hcan, &canFilter) != HAL_OK)
//	{
//		Error_Handler();
//	}
//
//	// ID standard : doit être aligné sur bits 31:21
//	canFilter.FilterIdHigh     = (CAN_ID_CALIBRATION_MODE << 5);  // 11 bits << 5
//	canFilter.FilterIdLow      = 0x0000;
//	canFilter.FilterMaskIdHigh = 0x07FF; // Select this ID only;
//	canFilter.FilterMaskIdLow  = 0xFFFF;
//
//	if (HAL_CAN_ConfigFilter(&hcan, &canFilter) != HAL_OK)
//	{
//		Error_Handler();
//	}
	//    /* --- Banque 1 : ID 0x410 (et dummy 0x000) --- */
	//    canFilter.FilterBank = 1;
	//    canFilter.FilterMode = CAN_FILTERMODE_IDLIST;
	//    canFilter.FilterScale = CAN_FILTERSCALE_32BIT;
	//    canFilter.FilterFIFOAssignment = CAN_FILTER_FIFO0;
	//    canFilter.FilterActivation = ENABLE;
	//
	//    canFilter.FilterIdHigh     = (CAN_ID_COMM_CHECKING << 5);
	//    canFilter.FilterIdLow      = 0x0000;
	//    canFilter.FilterMaskIdHigh = (0x000 << 5);   // dummy ID
	//    canFilter.FilterMaskIdLow  = 0x0000;
	//
	//    if (HAL_CAN_ConfigFilter(&hcan, &canFilter) != HAL_OK)
	//    {
	//        Error_Handler();
	//    }
}

void CAN_COM_Send(uint32_t id, uint8_t* data, uint8_t length) {
	/* Start the Transmission process */
	/* Configure Transmission header */
	TxHeader.StdId = id; // Set the ID of the message
	TxHeader.ExtId = 0x00; // Extended ID not used
	TxHeader.RTR = CAN_RTR_DATA;
	TxHeader.IDE = CAN_ID_STD;
	TxHeader.DLC = length;
	TxHeader.TransmitGlobalTime = DISABLE;

	/* Copy data to TxData
	 * This enable to free data buffer for other usage during buffer transfer */
	for (int i = 0; i < length; i++) {
		TxData[i] = data[i]; // copy data to TxData
	}

	/* Boucle de vérification de la disponibilité des boîtes aux lettres de transmission */
	while (HAL_CAN_GetTxMailboxesFreeLevel(&hcan) == 0) {
		// Toutes les boîtes aux lettres de transmission sont pleines.
		// Attendre un court instant avant de réessayer.
		// Cette temporisation est cruciale pour ne pas bloquer le processeur.
		vTaskDelay(1); // Attendre 1 milliseconde
	}

	if (HAL_CAN_AddTxMessage(&hcan, &TxHeader, TxData, &TxMailbox) != HAL_OK) {
		/* Transmission request Error - mailboxes full ? */
		assert_param(0);
		Error_Handler();
	}
}

void CAN_COM_ReceiveTask(void) {
	CANReceivedFrame_typeDef *canFrame;

	for(;;) {
		xSemaphoreTake(xCanReceptionSemaphore, portMAX_DELAY);

		// Process received message
		canFrame = pvPortMalloc(sizeof(CANReceivedFrame_typeDef));

		if (canFrame != NULL) {
			canFrame->header.id = CAN_RECEIVED_FRAME_ID;
			canFrame->can_id = RxHeader.StdId;
			canFrame->length = RxHeader.DLC;
			for (int i = 0; i < RxHeader.DLC && i < 8; i++) {
				canFrame->data[i] = RxData[i];
			}

			// Send to APP task
			if (xQueueSend(xAppLoopQueue, &canFrame, portMAX_DELAY) != pdPASS)  {
				// Queue full, drop the message
				vPortFree(canFrame);
			}
		} else {
			// Memory allocation failed, drop the message
		}
	}
}

/**
 * @brief  Rx Fifo 0 message pending callback in non blocking mode
 * @param  CanHandle: pointer to a CAN_HandleTypeDef structure that contains
 *         the configuration information for the specified CAN.
 * @retval None
 */
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan) {
	BaseType_t xHigherPriorityTaskWoken = pdFALSE; // used for task scheduling after using xQueueSendFromISR

	/* Get RX message */
	if (HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &RxHeader, RxData) != HAL_OK) {
		/* Reception Error */
		Error_Handler();
	}

	if (RxHeader.IDE == CAN_ID_STD) {
		xSemaphoreGiveFromISR(xCanReceptionSemaphore, &xHigherPriorityTaskWoken);

		/* Si une tâche plus prioritaire est réveillée, on force un context switch */
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	}
}

